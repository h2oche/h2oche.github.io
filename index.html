<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="ko">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="h2oche의 블로그">
<meta property="og:url" content="https://h2oche.github.io/index.html">
<meta property="og:site_name" content="h2oche의 블로그">
<meta property="og:locale" content="ko">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="h2oche의 블로그">






  <link rel="canonical" href="https://h2oche.github.io/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>h2oche의 블로그</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="ko">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">h2oche의 블로그</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">생각과 기억 저장소</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>홈</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>아카이브</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://h2oche.github.io/2019/03/12/pintos-guide-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h2oche">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h2oche의 블로그">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/12/pintos-guide-1/" class="post-title-link" itemprop="url">pintos-guide-1</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">작성일</span>
              

              
                
              

              <time title="Post created: 2019-03-12 01:23:57 / Updated at: 21:58:12" itemprop="dateCreated datePublished" datetime="2019-03-12T01:23:57+09:00">2019-03-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/pintos/" itemprop="url" rel="index"><span itemprop="name">pintos</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PINTOS-가이드-project-1"><a href="#PINTOS-가이드-project-1" class="headerlink" title="PINTOS 가이드 - project#1"></a>PINTOS 가이드 - project#1</h1><p>project#1 해결에 도움이 될만한 내용들을 작성하려 노력했다. 구성은 대충 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. alarm clock 시도해보기</span><br><span class="line">2. kernel thread 동작 이해하기</span><br><span class="line">3. thread scheduling 이해하기</span><br><span class="line">4. alarm clock 해결하기</span><br><span class="line">5. context switch 이해하기</span><br><span class="line">6. priority scheduling 해결하기</span><br></pre></td></tr></table></figure>
<p>우선 과제를 하기에 앞서 make check 했을 때, pintos가 잘 돌아가는지, 잘 돌아가는 시점이 git에 기록되어 있어 언제든 그 상태로 돌아갈 수 있는지 부터 확인해야 한다. git을 아직 안만들었다면 github에서 repository를 만들고 처음상태 핀토스를 commit 하자. 그리고 과제 중간중간에도 뭔가를 바꿨는데 잘 돌아간다면 항상 commit을 해서 언제든 그 상태로 돌아갈 수 있게 하는 습관을 들이는 것이 좋다. 돌아갈 곳이 있다는 것이 얼마나 좋은 것인지 과제를 하다보면 느끼게 될 것이다.</p>
<p>또, interrupt와 synchronization에 대한 설명은 핀토스 다큐먼트에 잘 묘사되어 있으니 꼭 appendix에서 해당 주제를 이해해야 한다. 이 것을 이해하게 되면 핀토스가 어떻게 돌아가는 지 이해하는 데에 큰 도움이 된다. 그리고 lib/kernel 에 보면 우리가 자유롭게 사용할 수 있는 유용한 자료구조 및 함수가 구현되어 있다. 특히 list.c, list.h는 앞으로 핀토스 과제를 하며 계속 사용하게 될 자료구조 이므로 사용법을 반드시 익혀야 한다. 주석에 list creation, list iteration 등에 대한 설명이 매우 잘 되있으므로 참고하면 된다.</p>
<p>참고로 1번 프로젝트와 2,3,4 프로젝트는 완전히 별개로 진행된다. 2번 프로젝트부터는 3번, 4번 프로젝트와 계속 이어진다.</p>
<h2 id="alarm-clock-시도해보기"><a href="#alarm-clock-시도해보기" class="headerlink" title="alarm clock 시도해보기"></a>alarm clock 시도해보기</h2><p>핀토스 첫번째 과제의 첫번째 task인 alarm clock이다. 본격적인 과제에 앞서 몸풀기 격인 task이다. 다큐먼트에 어쩌고 저쩌고 굉장히 간단한 것처럼 써져있지만, 사실 처음 핀토스를 시작한 입장에서 다큐먼트의 글을 읽으며 “뭔지 대충은 알겠는데, 그래서 뭐하라는거야?” 라는 생각이 들 것이라 생각한다. 문제 상황이 무엇인지 부터 정확히 파악해보자.</p>
<p>여기서 문제는 devices/timer.c 에 있는 timer_sleep() 함수가 busy-wait 방식으로 구현되어 있다는 것이다. alarm clock의 task는 timer_sleep()이 busy-wait을 하지 않도록 하는 것이다. busy-wait은 의미없는 명령을 실행하며 일정 시점이 지나기를 기다리는 행동을 의미하는데, 지금 구현은 반복문을 돌며, 일정 시간이 지나지 않았다면 thread_yield()를 통해 다음 thread에게 실행 권한을 넘기는 것을 반복한다. 즉, busy-wait으로 구현이 되어있다. 문제에서 요구하는 것은 반복문을 통해 계속 시간을 확인하지 않으면서(while을 없애라는 것이다), ticks 만큼의 시간이 지났을 때 thread가 실행 되도록 하는 것이다. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// busy-wait 으로 구현된 timer_sleep()</span></span><br><span class="line"><span class="keyword">while</span> (timer_elapsed (start) &lt; ticks) </span><br><span class="line">    thread_yield ();</span><br></pre></td></tr></table></figure>
<p>어떻게 해야될까? 우선 이 것을 하려면 핀토스의 kernel thread와 interrupt 동작을 이해해야 한다.</p>
<h2 id="kernel-thread-동작-이해하기"><a href="#kernel-thread-동작-이해하기" class="headerlink" title="kernel thread 동작 이해하기"></a>kernel thread 동작 이해하기</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">요약</span><br><span class="line">1. kernel thread는 하나의 task를 개념화한 것이다.</span><br><span class="line">2. thread_init(), thread_start()를 통해 최초의 kernel thread(=idle,main)가 만들어진다.</span><br></pre></td></tr></table></figure>
<p>thread.c, thread.h 에 kernel thread 에 대한 모든 코드들이 담겨있다. 그리고 알아둬야 할 것은 핀토스에서 계속 언급되는 thread(=kernel thread)는 우리가 평소에 생각하던 process 안에서 동작하는 thread가 아니라는 것이다. 그 전에 우리가 알고있던 thread는 OS에서 user thread라는 별도의 명칭으로 불린다.</p>
<h3 id="kernel-thread"><a href="#kernel-thread" class="headerlink" title="kernel_thread()"></a>kernel_thread()</h3><p>kernel thread가 어떤 개념인지 부터 이해해보자. kernel thread의 모든 동작은 thread.c 의 <strong>kernel_thread()</strong> 를 보면 이해할 수 있다. 코드는 굉장히 단순하다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Function used as the basis for a kernel thread. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">kernel_thread (thread_func *function, <span class="keyword">void</span> *aux) </span><br><span class="line">&#123;</span><br><span class="line">  ASSERT (function != <span class="literal">NULL</span>);</span><br><span class="line">                    </span><br><span class="line">  intr_enable ();       <span class="comment">/* 인터럽트를 끈다 */</span></span><br><span class="line">  function (aux);       <span class="comment">/* 어떤 기능을 하는 함수를 실행한다 */</span></span><br><span class="line">  thread_exit ();       <span class="comment">/* 함수가 끝나면 kernel thread를 종료한다. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이게 kernel thread 동작의 전부이다. 하나의 kernel thread는 하나의 함수를 실행시키고 이후 종료되는 것이다. 즉, 한 개의 kernel thread는 컴퓨터에서 수행하는 한 개의 task를 개념화한 것이다. 사실 모든 프로그램의 동작은 추상적으로 생각해 봤을 때, 모두 kernel_thread()같이 동작한다. 핀토스에서 그림판과 파워포인트를 쓰는 상황을 생각해 보자.</p>
<p><strong>그림판 프로그램 실행 과정</strong></p>
<ol>
<li>kernel thread 하나를 만든다.</li>
<li>그림판의 모든 기능을 수행하는 함수를 실행해서, 유저가 원하는 그림을 그려준다.</li>
<li>유저가 그림판을 끄면, 그림판을 수행한 kernel thread를 없앤다.</li>
</ol>
<p><strong>파워포인트 프로그램 실행 과정</strong></p>
<ol>
<li>kernel thread 하나를 만든다.</li>
<li>파워포인트의 모든 기능을 수행하는 함수를 실행해서, 유저의 발표 슬라이드를 만들어준다.</li>
<li>유저가 파워포인트를 끄면, 파워포인트를 수행한 kernel thread를 없앤다.</li>
</ol>
<p>컴퓨터에서 한 번에 kernel thread만 사용하면 얼마나 행복할까? 그러면 이렇게 핀토스 하느라 고생하지 않아도 될텐데.. 이 모든 문제의 원인은 한 개의 컴퓨터에 여러개의 kernel thread가 <strong>동시에</strong> 돌아가야 한다는 것이다. 즉, 파워포인트를 다 쓴 다음에 그림판을 쓰거나, 그림판을 다 쓴 다음에 파워포인트를 쓰는게 아니라 파워포인트와 그림판이 <strong>동시에</strong> 실행되어야 한다는 것이다. </p>
<p>여러 kernel thread중 어떤 thread가 CPU를 점유할 것인지에 대한 정책을 scheduling 이라고 하고, scheduling을 할 때 각각의 kernel thread가 어떤 state를 가지고 있는지가 중요하다. scheduling을 살펴보기 전에 kernel thread가 어떻게 시작되고 만들어지는지 부터 살펴보자.</p>
<h3 id="thread-init-init-thread-thread-start-thread-create-idle"><a href="#thread-init-init-thread-thread-start-thread-create-idle" class="headerlink" title="thread_init(), init_thread(), thread_start(), thread_create(), idle()"></a>thread_init(), init_thread(), thread_start(), thread_create(), idle()</h3><p>init.c 에 main을 보면 thread_init(), thread_start(), run_actions() 순으로 실행흐름이 이어지는 것을 확인할 수 있다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_init</span> <span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ASSERT (intr_get_level () == INTR_OFF);</span><br><span class="line"></span><br><span class="line">  lock_init (&amp;tid_lock);</span><br><span class="line">  list_init (&amp;ready_list);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set up a thread structure for the running thread. */</span></span><br><span class="line">  initial_thread = running_thread ();</span><br><span class="line">  init_thread (initial_thread, <span class="string">"main"</span>, PRI_DEFAULT);</span><br><span class="line">  initial_thread-&gt;status = THREAD_RUNNING;</span><br><span class="line">  initial_thread-&gt;tid = allocate_tid ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>thread_init()은 init.c의 main()을 실행하고 있는 현재의 실행흐름을 하나의 kernel thread로 생각하고 초기화 한다. 핀토스에서 만들어지는 최초의 kernel thread 가 여기서 만들어진다. thread.h에 있는 <strong>struct thread</strong> 를 살펴보면 뭔가 kernel thread에 들어가야될 것만 같은 여러 정보들(이름, priority, tid, …)이 있는데, 이 구조체의 값들이 init_thread() 함수를 통해 초기화 된다.</p>
<p>이후 thread_start()를 보자.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_start</span> <span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Create the idle thread. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">idle_started</span>;</span></span><br><span class="line">  sema_init (&amp;idle_started, <span class="number">0</span>);</span><br><span class="line">  thread_create (<span class="string">"idle"</span>, PRI_MIN, idle, &amp;idle_started);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Start preemptive thread scheduling. */</span></span><br><span class="line">  intr_enable ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Wait for the idle thread to initialize idle_thread. */</span></span><br><span class="line">  sema_down (&amp;idle_started);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 함수의 역할은 idle thread를 만들고, interrupt를 활성화 시키는 것이다. thread_create() 함수를 통해 idle thread 를 생성하게 된다. idle thread는 말 그대로 아무것도 하지 않는 thread인데, ready queue가 비어있을 때, idle thread가 동작하므로써 CPU가 무조건 하나의 kernel thread를 실행시키고 있는 상태를 유지하게 만들어 준다. idle thread의 동작은 idle() 함수에 정의되어 있다. 더 설명하기 전에 thread_create()의 내용을 정리해보자.</p>
<ol>
<li>thread를 위한 memory를 할당한다. 페이지 하나(4KB)가 할당된다.</li>
<li>init_thread()를 통해 thread 구조체를 초기화 시킨다.</li>
<li>뭔가 알 수 없는 동작을 한다.</li>
<li>마지막에 thread_unblock()을 통해 생성한 thread를 ready queue 에 넣는다.</li>
</ol>
<p>여기서 알 수 없는 동작은 context switch에 대해 설명할 때 알아볼 것이고, ready queue에 대한 설명 역시 scheduling에서 할 것이다. 대충 thread_create()가 끝나서 새로운 kernel thread가 만들어지면, 바로 실행되는 것이 아니라 실행 대기중인 상태로 된다 정도로 이해하면 될 것 같다.</p>
<p>다음에 interrupt를 활성화 하게 되는데, 여기서는 interrupt를 활성화 시켜야만 scheduling이 작동할 수 있다는 것 정도만 알고 넘어가자.</p>
<p>그런데 여기서 처음 등장하는 semaphore는 뭘까? semaphore는 sema_up(), sema_down()이 한 쌍으로 동작한다. 함수이름에서 알 수 있듯이 sema_up(&amp;sema)는 sema의 값을 1 증가시키고, sema_down(&amp;sema)는 sema의 값을 1 감소시킨다. 그런데 만약 sema_down(&amp;sema)를 할 때, sema의 값이 0이라면 실행을 멈추고, sema가 1이 될 때까지 기다린다.</p>
<p>semaphore가 뭔지까지 이해가 됬으면 thread_start()를 이해할 수 있다.</p>
<ol>
<li>thread_create()를 통해 idle thread를 만든다.</li>
<li>interrupt를 활성화 시켜, idle thread가 CPU를 점유할 수 있게 만들어 준다.</li>
<li>idle() 함수가 sema_up(&amp;idle_started)를 실행하기 전까지 “main” thread는 sema_down(&amp;idle_started)에 멈춰 있는다.</li>
<li>idle() 함수가 sema_up(&amp;idle_started)를 실행하면(=모든 실행준비를 마치고 이제 다른 kernel thread를 생성할 준비가 되면) 다음으로 넘어가 run_actions()을 실행한다.</li>
</ol>
<p>마지막으로 알아둬야 할 것은 idle thread와 main thread는 사실 같은 것이라는 것이다. 이유는 코드를 잘 살펴보면 알 수 있다.</p>
<h3 id="thread-current"><a href="#thread-current" class="headerlink" title="thread_current()"></a>thread_current()</h3><p>작성 예정</p>
<h2 id="thread-scheduling"><a href="#thread-scheduling" class="headerlink" title="thread scheduling"></a>thread scheduling</h2><p>핀토스에서는 한 개의 kernel thread만이 CPU를 점유할 수 있다. 그렇다면 여러 kernel thread 가 있을 때, 어떤 kernel thread가 CPU를 점유하게 하는게 좋을까? 이에 대한 정책을 thread scheduling 이라고 한다. scheduling은 말 그대로 정책이기 때문에, thread 처럼 메모리 공간을 차지하는 것이 아니다. thread와 관련한 코드 곳곳에 이 정책들이 녹아들어 있다.</p>
<p>우선 thread의 status부터 알아보자.</p>
<h3 id="thread-status"><a href="#thread-status" class="headerlink" title="thread status"></a>thread status</h3><p><img src="/images/thread_lifecycle.png" alt="thread status diagram"></p>
<p>핀토스에서 kernel thread는 총 4개의 status를 가진다.</p>
<ul>
<li>thread_running : 현재 CPU를 점유중인 kernel thread</li>
<li>thread_ready : CPU를 점유중이지는 않지만 언제든 실행을 할 준비가 된 kernel thread</li>
<li>thread_dying : 모든 할 일을 마쳐 죽음을 대기중인(memory에서 사라질) kernel thread</li>
<li>thread_blocked : 실행준비가 되지 않은, 다시말해 어떤 이벤트가 일어나기를 기다리고 있는 kernel thread</li>
</ul>
<p>thread의 status가 어떤 상황에서 바뀌는지 위에 그림에 친절히 나타나있다. 헷갈릴 때 자주 참고하면 좋을 것 같다. 아무튼 여기서 중요한 것은 status가 thread_ready인 모든 kernel thread들이 thread.c에 전역으로 선언된 <strong>ready_list</strong> 에 담기게 된다는 것이다. 아까 계속 언급한 ready queue의 정체가 ready_list 이다.</p>
<h3 id="scheduling"><a href="#scheduling" class="headerlink" title="scheduling"></a>scheduling</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">요약 : ready_list 에 thread를 어떤 순서로 넣고, 어떤 순서로 뺄 지를 정하는 것이 scheduling이다.</span><br></pre></td></tr></table></figure>
<p>뭔가 점점 감이 잡힐 것이다. 핀토스에서 scheduling은 ready_list를 어떻게 관리하고, schedule() 함수 안에서 호출되는 next_thread_to_run() 함수에 의해 다음 CPU를 점유할 kernel thread를 정할 때, 어떤 kernel thread를 ready_list에서 꺼낼지에 대한 정책을 말한다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *</span></span><br><span class="line"><span class="class"><span class="title">next_thread_to_run</span> (<span class="title">void</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> (list_empty (&amp;ready_list))</span><br><span class="line">    <span class="keyword">return</span> idle_thread;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//ready_list의 맨 앞에서 꺼냄</span></span><br><span class="line">    <span class="keyword">return</span> list_entry (list_pop_front (&amp;ready_list), struct thread, elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">thread_unblock (struct thread *t) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level;</span><br><span class="line"></span><br><span class="line">  ASSERT (is_thread (t));</span><br><span class="line"></span><br><span class="line">  old_level = intr_disable ();</span><br><span class="line">  ASSERT (t-&gt;status == THREAD_BLOCKED);</span><br><span class="line">  <span class="comment">//ready_list의 맨 뒤에 넣음</span></span><br><span class="line">  list_push_back (&amp;ready_list, &amp;t-&gt;elem);</span><br><span class="line">  t-&gt;status = THREAD_READY;</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드를 보면 알 수 있듯이, 현재 핀토스의 scheduling은 round-robin 방식으로 만들어져 있다. 즉, 어떤 kernel thread의 status가 thread_ready 변경되어 ready_list로 들어갈 때, 항상 ready_list의 맨 마지막으로 들어가게 되고, next_thread_to_run() 함수에서 다음 실행할 kernel thread를 정할 때, 항상 ready_list의 맨 앞에서 꺼낸다. 만약 ready_list가 비어있을 경우, 맨 처음 생성한 idle thread를 실행한다.</p>
<p>연습삼아 핀토스의 scheduling 정책을 뒤에서 하게 될 priority scheduling으로 바꾼다고 생각해보자. 크게 생각할 것이 없다. 어떻게 kernel thread를 ready_list에 넣고 뺄 것인지만 생각하면 된다.</p>
<ol>
<li>넣을 때 : ready_list가 priority의 내림차순으로 정렬되게 넣음</li>
<li>뺄 때 : ready_list의 맨 앞에서 꺼냄</li>
</ol>
<h3 id="scheduling이-일어나는-시점"><a href="#scheduling이-일어나는-시점" class="headerlink" title="scheduling이 일어나는 시점"></a>scheduling이 일어나는 시점</h3><p>마지막으로 schedule이 언제 일어나게 되는지만 확인하면 scheduling에 대해 거의 모두 이해했다고 할 수 있다. 이걸 확인하려면 언제 schedule() 함수가 불리는지만 보면 된다. scheduling을 한다 == schedule() 함수를 실행한다 로 이해하면 된다. schedule() 함수가 호출되는 시점은 다음과 같다.</p>
<ol>
<li>thread_yield() 함수가 호출될 때</li>
<li>thread_block() 함수가 호출될 때</li>
<li>thread_exit() 함수가 호출될 때</li>
</ol>
<p>즉, 위의 thread status 상태 변화를 나타낸 그림에서 status가 thread_running에서 다른 무엇인가로 바뀔 때, schedule()이 호출된다는 것을 알 수 있다.</p>
<p>그런데, 만약 현재 실행중인 thread가 thread_yield(), thread_block(), thread_exit()을 실행하지 않는다면, schedule()은 영원히 실행되지 않을까? 답은 당연히 <strong>아니다</strong>이다. 그렇게 되면 안된다. 만약 핀토스가 이렇게 동작한다면 그림판과 파워포인트가 동시에 실행되는 것이 아니라, 그림판을 다 끝낸다음에야 파워포인트를 실행할 수 있게 된다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Timer interrupt handler. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">timer_interrupt (struct intr_frame *args UNUSED)</span><br><span class="line">&#123;</span><br><span class="line">  ticks++;</span><br><span class="line">  thread_tick ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">thread_tick (<span class="keyword">void</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span> = <span class="title">thread_current</span> ();</span></span><br><span class="line">  <span class="comment">/* Enforce preemption. */</span></span><br><span class="line">  <span class="keyword">if</span> (++thread_ticks &gt;= TIME_SLICE)</span><br><span class="line">    intr_yield_on_return ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>비밀은 timer_interrupt 에 있다. interrupt가 어떤 것인지는 핀토스 다큐먼트를 참고하면 된다. interrupt가 있어야지만 핀토스가 parallel하게 동작하게 된다. 잘 이해가 안간다면 그냥 kernel thread가 무슨 명령을 실행하고 있던지에 상관없이 시시때때로 매우 짧은 단위시간마다 devices/timer.c 에 있는 timer_interrupt() 함수를 실행시킨다고 생각하면 될 것 같다.</p>
<p>모든 interrupt는 interrupt.c에 정의되어 있는 intr_handler() 에서부터 출발한다(실제로는 아니지만 그렇다고 생각해도 동작을 이해하는 데는 문제가 없다). intr_handler()에서 timer_interrupt()가 실행되면 thread_tick()도 실행되게 되는데, 이 함수에서는 thread_tick 은 thread_ticks를 1 증가시키고, 만약 이 값이 TIME_SLICE 값보다 크다면 intr_yield_on_return()을 실행하게 되고, yield_on_return = true가 된다. 이후 intr_handler()의 마지막에서 yield_on_return = true 이면 thread_yield()가 실행된다.</p>
<p>정리하면 </p>
<ol start="0">
<li>timer interrupt 발생</li>
<li>intr_handler() 실행</li>
<li>timer_interrupt() 실행</li>
<li>thread_tick() 실행</li>
<li>thread_ticks가 TIME_SLICE(=4) 이상이면 intr_yield_on_return() 실행해서 yield_on_return = true로 바꿈(thread_ticks 는 schedule() 에서 0으로 초기화 된다. 새로운 kernel thread가 thread_running이 된 지 얼마나 지났는지를 기록하는 전역변수이다)</li>
<li>intr_handler()의 마지막에서 yield_on_return 가 true이면 thread_yield()</li>
</ol>
<p>즉, 4 tick 마다 무조건 thread_yield()가 실행되는 것이다.</p>
<h2 id="alarm-clock-해결하기"><a href="#alarm-clock-해결하기" class="headerlink" title="alarm clock 해결하기"></a>alarm clock 해결하기</h2><p>여기까지 모두 이해했다면 alarm clock 에서 어떤 것을 하라는 지 명확해진다.</p>
<ol>
<li>timer_sleep()이 호출되면 어느 시점에 이 thread가 다시 thread_ready가 되야되는지를 <strong>struct thread</strong>의 새로운 필드를 만들어서 저장하고, ready_list와는 별도로 sleep_list를 하나 만들어서 현재 thread를 넣은 다음 현재 thread를 block 시킨다.</li>
<li>timer_interrupt()가 호출될 때 마다 sleep_list를 보며 깨어날 thread가 있는지 확인하고, 깨어날 시점이 지났다면 해당 thread를 unblock시킨다.</li>
</ol>
<p>이렇게 하면 busy-wait을 하지 않는 timer_sleep()을 구현할 수 있다. list_push_back()를 사용해서 구현해도 되지만, list_insert_ordered() 함수를 잘 활용하면 더 잘 구현할 수 있다.</p>
<h2 id="context-switch-이해하기"><a href="#context-switch-이해하기" class="headerlink" title="context switch 이해하기"></a>context switch 이해하기</h2><p><a href="https://drive.google.com/file/d/1OD-KQGAJ5pzf0l3Cvu3wOIcO9si3pkLj/view" target="_blank" rel="noopener">링크 - thread and process switch in pintos</a>에 이에 대한 설명이 비록 영어이지만 매우 잘 되어있다. 핀토스 다큐먼트에 </p>
<p><em>You will understand the thread system once you understand why and how the switch_threads() that gets called is different from the switch_threads() that returns</em></p>
<p>라고 나와있을 정도로 thread system 이해에 핵심적인 부분이니 꼭 이해하려고 해보자.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">schedule (<span class="keyword">void</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">curr</span> = <span class="title">running_thread</span> ();</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">next</span> = <span class="title">next_thread_to_run</span> ();</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">  ASSERT (intr_get_level () == INTR_OFF);</span><br><span class="line">  ASSERT (curr-&gt;status != THREAD_RUNNING);</span><br><span class="line">  ASSERT (is_thread (next));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (curr != next)</span><br><span class="line">  	 <span class="comment">// next = curr, prev = curr</span></span><br><span class="line">    prev = switch_threads (curr, next);</span><br><span class="line">  schedule_tail (prev); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>대충 핵심 아이디어는 switch_threads(curr,next)가 호출되면 running thread가 curr에서 next로 바뀐다는 것이다. switch_threads에서 무슨 일이 일어나길래 갑자기 실행환경이 바뀌어 버리는 것일까? 답은 간단하다. CPU에 있는 stack pointer를 curr-&gt;stack에서 next-&gt;stack으로 변경하는 것이다. </p>
<p>왜 stack pointer가 바뀌면 실행환경이 바뀌었다고 생각할 수 있는지 상상해보자. 잘 생각해 보면 모든 thread가 schedule()에서 시작하고, schedule()에서 종료되므로, stack pointer를 바꿔줌으로써 다른 thread를 실행하고 있다고 생각할 수 있다는 것을 알 수 있을 것이다.</p>
<p>또 한가지 눈여겨 볼만한 것은 thread는 context switch를 할 때, “interrupt에서 빠져나온 것 처럼” 행동한다는 것이다. 위에 thread_create()에서 alloc_frame()을 포함한 “이걸 왜하는 거지?” 하는 생각이 들었던 코드가 바로 kernel_thread() 함수에서 interrupt가 걸렸던 것 처럼 fake stack frame을 쌓는 과정이라고 생각하면 될 것 같다(처음 만들어진 thread의 stack에는 아무것도 없으므로).</p>
<p>이 모든 마법같은 일들이 threads/switch.S에 어셈블리코드로 작성되어 있다. 해석하기가 그리 어렵지는 않으므로 context switch의 메커니즘이 이해가 간다면, 한 번 살펴보는 것도 괜찮은 공부가 될 것 같다.</p>
<h2 id="priority-scheduling-해결하기"><a href="#priority-scheduling-해결하기" class="headerlink" title="priority scheduling 해결하기"></a>priority scheduling 해결하기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><ul>
<li>priority scheduling<ul>
<li>struct thread에 보면 priority 라는 항목이 있다. block되지 않은 thread 중 가장 높은 priority를 가진 thread가 CPU를 차지하도록 만들면 된다.</li>
</ul>
</li>
<li>priority inversion problem<ul>
<li>낮은 priority를 가진 thread가 어떤 자원을 차지하고 있어서, 높은 priority를 가진 thread가 실행되지 못하고 있는 상황이다.</li>
<li>각각의 priority가 0, 30, 60 인 thread A,B,C 가 있고, A가 lock을 acquire 한 상황을 생각해보자. priority scheduling에 의하면 C가 CPU를 차지하게 된다. 그런데 C가 실행 도중 A가 가진 lock을 필요로 한다면, A가 아직 lock을 release하지 않았으므로, C가 block 이 되는데, priority scheduling에 의해 B가 CPU를 계속 차지하므로 C는 계속 block 상태에 놓이게 된다. 이 것은 우리가 원하는 상황이 아니다.</li>
<li>B를 계속 실행하는 것이 아니라, A의 priority를 높여서 A가 lock release를 하게 만든 다음 A의 priority를 다시 낮추고, C를 unblock 시켜 CPU를 차지하게 하는 것이 조금 더 나은 정책이다. 이렇게 C로 인해 A의 priority가 높아지는 상황을 <strong>priority donation</strong>이라고 하고, 이 것을 구현해야 한다. 다행히 lock에 대해서만 구현하면 된다고 한다.</li>
</ul>
</li>
</ul>
<h3 id="현재-핀토스-분석"><a href="#현재-핀토스-분석" class="headerlink" title="현재 핀토스 분석"></a>현재 핀토스 분석</h3><ul>
<li>위에 scheduling에서 보았듯이 현재 핀토스는 round-robin scheduling을 채택하고 있다</li>
</ul>
<h3 id="구현-디자인"><a href="#구현-디자인" class="headerlink" title="구현 디자인"></a>구현 디자인</h3><p>어디를 손봐야 할지부터 생각해 보자. tests/threads 폴더에 있는 여러 test case들을 보며 이 코드가 어떻게 실행되어야 되는지 부터 생각하면 구현할 내용이 훨씬 명확해 진다. 또, 핀토스 코드와 함께 제출해야 되는 pintos design document의 질문들을 보는 것도 구현 디자인에 큰 도움이 된다. 꼭꼭 test-case에 있는 코드가 어떻게 동작할 지 분석하고, 그 다음 어떻게 구현할지를 생각해야 한다.</p>
<p>생각할 거리가 있는 test case 몇 개를 뽑아보았다(사실 거의 전부이다).</p>
<ul>
<li>priority-donate-multiple<ul>
<li>priority가 30인 thread A가 lock a,b를 얻고, 각각 priority가 31,32인 thread B,C를 차례대로 생성하는데, thread B,C는 각각 lock a,b를 필요로 한다.</li>
<li>priority donation에 의해 A의 priority는 30 -&gt; 31 -&gt; 32 가 되고, A가 lock b,a 순으로 release하면 C,B 순서로 thread 가 실행된 후, A의 priority는 다시 32 -&gt; 31 -&gt; 30이 되어야 함.</li>
</ul>
</li>
<li>priority-sema</li>
<li>priority-condvar</li>
<li>priority-fifo</li>
<li>priority-donate-chain</li>
<li>priority-donate-nest</li>
<li>priority-donate-sema</li>
</ul>
<p>priority의 변화가 언제 일어나고, 어떻게 thread를 ready_list에 넣고 뺄 것인지, 각각의 cond_var, semaphore에 들어있는 waiter_list를 어떻게 관리해야 할지, priority donation이 끝나고 어떻게 원래의 priority를 회복해야 할 지 생각해야 된다.</p>
<p><strong>ready_list에 어떻게 넣고 뺄 것인가?</strong></p>
<ol>
<li>넣을 때 : ready_list가 priority의 내림차순으로 정렬되게 넣음</li>
<li>뺄 때 : ready_list의 맨 앞에서 꺼냄</li>
</ol>
<p><strong>priority의 변화는 언제 일어날까?</strong></p>
<ol>
<li>thread_create()를 통해 새로운 thread가 만들어 질 때</li>
<li>thread_set_priority()를 통해 현재 thread의 priority가 바뀔 때</li>
<li>thread_unblock()이 될 때</li>
<li>sema_up(), sema_down(), cond_wait(), cond_singal(), lock_acquire(), lock_release() 할 때 </li>
</ol>
<p>나는 struct thread에 thread가 가지고 있는 lock의 list 항목을 추가하고, struct lock에 holder의 원래 priority를 추가로 기록하는 방법으로 해결했다.</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://h2oche.github.io/2019/03/12/pintos-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h2oche">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h2oche의 블로그">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/12/pintos-guide/" class="post-title-link" itemprop="url">pintos_guide</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">작성일</span>
              

              
                
              

              <time title="Post created: 2019-03-12 01:19:48 / Updated at: 01:23:45" itemprop="dateCreated datePublished" datetime="2019-03-12T01:19:48+09:00">2019-03-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/pintos/" itemprop="url" rel="index"><span itemprop="name">pintos</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PINTOS-가이드"><a href="#PINTOS-가이드" class="headerlink" title="PINTOS 가이드"></a>PINTOS 가이드</h1><p>##시작하기에 앞서</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">요약</span><br><span class="line">1. 핀토스는 어렵다</span><br><span class="line">2. thread, process, virtual memory, file system 과제를 수행하게 된다</span><br><span class="line">3. (개인적으로)힘들었던 만큼 남는 것이 많았다</span><br></pre></td></tr></table></figure>
<p>핀토스는 실제로 사용되는 OS가 아닌 학생들이 과제를 통해 OS를 조금 더 잘 이해하기 위해 만들어진 교육용 OS이다. 교육용이기는 하지만 실제 OS에 사용될만한 핵심 아이디어들이 그대로 반영되어 있고 따라서 프로젝트 규모가 작지 않기 때문에 앞으로 수행할 과제들은 결코 만만하지가 않다. 과제를 해내기 바빠 머릿속에서 정리 못했던 것들을 정리하고, 내가 겪은 시행착오들이 다른 사람에게 도움이 될 수 있을까 싶어서 이 글을 쓰기로 결심했다. 여기에 있는 거의 대부분의 내용과 구성은 내 주관이 많이 반영되었다는 점을 주의해서 읽으면 좋을 것 같고, 항상 공식 핀토스 다큐먼트를 제일 기본적이고 중요한 레퍼런스로 여겼으면 한다. 먼저 핀토스의 전체적인 구성과 내가 핀토스를 통해 얻었던 것부터 시작을 해야 될 것 같다. </p>
<h3 id="핀토스-과제의-구성"><a href="#핀토스-과제의-구성" class="headerlink" title="핀토스 과제의 구성"></a>핀토스 과제의 구성</h3><p>핀토스 프로젝트의 과제는 크게 다음과 같이 4가지 부분으로 나뉘게 된다.</p>
<ol>
<li>thread(*** - 핀토스를 처음 접하기 때문에 전체적인 동작을 이해하는게 빡세다 )</li>
<li>process(** - 시스템 콜만 구현하면 되기 때문에 그나마 제일 쉽다 )</li>
<li>virtual memory(*** - 다른 과제와 달리 맨땅에 헤딩을 해야 한다 )</li>
<li>file system(<em>**</em> - 기본적으로 해야할 게 많고 거의 모든 부분에서 synchronization 문제를 고민해야한다, 1,2,3 과제가 모두 연관되어 있다 )</li>
</ol>
<p>각 과제 옆에 표시된 별표는 내가 과제를 하면서 느꼈던 체감 난이도를 의미하고 별표가 많을수록 나한테 어려웠던 또는 힘들었던 과제였다. 내가 왜 이렇게 느꼈는지에 대한 이유도 적었는데 이에 대한 자세한 내용은 각 과제에 대한 가이드에서 설명하겠다. 1번 과제를 제외한 2,3,4 과제는 서로 연관되어 있다. 즉, 3번 과제는 2번 과제가 완료되었다는 전제에서 출발하고, 4번 과제는 2,3번 과제가 완료되었다는 전제에서 출발한다. 따라서 중간에 과제를 던질 수가 없고, 2번 과제의 구현에서 오류가 있었을 경우 3,4번 과제까지 영향을 주기 때문에 테스트 케이스가 잡아내지 못한 부분까지 오류 없이 정확히 구현해 놓아야 나중에 예상치 못한 버그에 마주치지 않게 된다.</p>
<h3 id="핀토스를-통해-얻을-수-있는-것"><a href="#핀토스를-통해-얻을-수-있는-것" class="headerlink" title="핀토스를 통해 얻을 수 있는 것"></a>핀토스를 통해 얻을 수 있는 것</h3><p>전산과에서 악명이 매우 높은 수업이다. 매드클라운이 랩을 귀에 때려박는다면, 핀토스는 OS를 내 몸에 때려박는다. 그만큼 쉽지 않고 고통스러운 한 학기가 기다리고 있다. 내가 개인적으로 제일 힘들었던 것은 과제의 난이도도 있지만 한 학기 내내 핀토스 프로젝트가 이어진다는 점이었다. 과제 4번에서 All Pass가 뜨는 것을 보기 전까지(=기말고사 끝날 때까지) 핀토스는 끝나지 않는다. 1번 과제 듀가 끝나면 바로 2번 과제가 시작되고 2번 과제가 끝나면 바로 3번 과제가 시작되고 3번 과제가 끝나면 바로 4번 과제가 시작된다. 힘들지만 성실히 과제를 한다면 그만큼 얻을 것도 매우 많은 수업이라고 생각을 한다. 내가 이 수업을 통해 얻었던 것은 크게 3가지 정도로 생각해 볼 수 있을 것 같다.</p>
<ol>
<li>C 프로그래밍 능력</li>
<li>parallel하게 동작하는 프로그램에 대한 이해</li>
<li>OS에 대한 확실한 이해</li>
</ol>
<p>먼저 C로 되어있는 수십개의 파일에 걸친 수천 줄의 코드의 동작을 이해하고 또 자신의 아이디어를 그 코드 안에 담아야 하기 때문에  프로그래밍 능력이 늘 수 밖에 없는 것 같다. 또한, 몇줄의 잘못된 코드가 전혀 예상치 못한 오류, 결과를 불러오기 때문에 코드를 하기 전에 충분히 생각하고, 디자인에 대해 고민하는 과정 또한 좋은 경험이었던 것 같다.</p>
<p>두 번째로, 핀토스에서는 여러 스레드가 동시에 동작하기 때문에 모든 코드가 parallel하게 동작해도 문제 없이 작동해야 한다. 즉, A번째 줄을 실행하다 전혀 다른 B번째 줄이 동시에 실행 되어도 문제가 없이 동작해야 한다. 때문에 알고리즘과 로직 뿐만 아니라 평소에 잘 고려하지 않던 syncrhonization 문제에 대해 깊게 고민해 보게 되었다.</p>
<p>마지막으로 OS 수업에서 배운 여러 아이디어들을 직접 코드로 구현해 가면서 이론으로 배울 때 모호했던 개념들을 확실히 깨닫고, 수업 때 생각하지 못했던 여러 코너케이스들을 실제 구현을 통해 살펴 볼 수 있었다.</p>
<h2 id="과제-0-핀토스의-구성-메커니즘-이해하기"><a href="#과제-0-핀토스의-구성-메커니즘-이해하기" class="headerlink" title="과제 0 - 핀토스의 구성, 메커니즘 이해하기"></a>과제 0 - 핀토스의 구성, 메커니즘 이해하기</h2><p>처음 압축된 프로젝트를 다운받아 열어보았을 때, 아마존 숲에 떨어진 기분이었다. 정체모를 폴더가 여러개 있고 수십개의 소스, 헤더 파일이 있고, 다큐먼트 또한 수십페이지이기 때문에 어디서 부터 시작해야 될지 참 막막했었다. 먼저 전체적인 프로젝트의 구성부터 살펴보아야 할 것 같다.</p>
<h3 id="핀토스-프로젝트의-폴더-구성"><a href="#핀토스-프로젝트의-폴더-구성" class="headerlink" title="핀토스 프로젝트의 폴더 구성"></a>핀토스 프로젝트의 폴더 구성</h3><ul>
<li>/boshs, /misc : 과제를 하면서 이 폴더에 들어간 적이 없다.</li>
<li>/examples : 핀토스 위에서 돌려볼 수 있는 예제 프로그램들이 있는데, 2번 과제인 process 를 마쳐야 비로소 제대로 동작하기 시작할 것이다. 2번 과제 후, 핀토스에 문제가 없나 확인해 보는 용도로는 쓸 수 있을 것 같지만, 이미 많은 테스트 케이스를 통해 검증을 하기 때문에 큰 의미는 없다. 내가 만든 오에스에서 일반적인 프로그램들이 잘 돌아가는 구나 확인하고 싶으면 컴파일을 해서 돌려보면 될 것 같다. 단순 예제 프로그램들이기 때문에 이 폴더를 지워도 과제에 영향은 없다.</li>
<li>/utils : 내가 만든 OS를 구동할 수 있는 Perl 스크립트가 담긴 파일이다. 스크립트를 이해할 필요는 없고, path에 이 폴더를 등록해 놓았다면 그 이후 크게 신경쓰지 않아도 되는 폴더이다.</li>
<li>/devices : 컴퓨터에서 사용하는 여러 I/O 장치들을 사용하기 위한 인터페이스를 구현한 소스가 담긴 폴더이다. 타이머, 키보드, 디스크 등 여러 외부 장치들을 프로젝트 안에서 사용하고 싶을 때, 여기서 찾아보면 좋을 것 같다. 실질적으로는 타이머를 주로 쓰게 될 것이다.</li>
<li>/tests : 우리가 만든 오에스의 결과물들이 통과해야 하는 여러 테스트 케이스의 소스코드들이 담긴 폴더이다. 이 안에 여러 폴더가 있는데 의미는 간단하다. /threads, /userprog, /vm, /filesys 안에 각각 1,2,3,4 번 과제에서 통과해야 하는 테스트 케이스들이 소스코드로 작성되어 있다. 오에스가 시뮬레이터 위에서 A.c 라는 테스트 파일을 실행했을 때, 그에 대한 결과가 A.ck 파일과 일치하면 테스트가 통과된다.</li>
</ul>
<p>이 이후는 실제 우리가 만들게 되는 오에스에 직접적으로 들어가게 되는 소스들이 담긴 폴더들이다.</p>
<ul>
<li>/lib : 1,2,3,4 번 과제를 하면서 두루두루 쓰이게 되는 여러 편의 기능들을 구현한 코드를 모아 놓은 폴더이다. printf, malloc 같이 C 프로그래밍을 하면서 자주쓰는 함수들과 list, bitmap, hash table 같은 자료구조가 구현되어 있다. 이에 대한 자세한 사용법과 설명은 핀토스 다큐먼트의 부록에 상세히 설명되어 있다.</li>
<li>/threads : 1번째 과제를 진행하게 될 폴더이고, 오에스에서 사용되는 기본적인 thread가 구현되어 있다. OS의 main function 이 여기 안에 있다. </li>
<li>/userprog : 2번과제를 진행하게 될 폴더이고, process가 구현되어 있다.</li>
<li>/vm : 3번과제를 진행하게 될 폴더… 이지만 아무것도 들어있지 않다. virtual memory를 직접 구현하게 된다.</li>
<li>/filesys : 4번과제를 진행하게 될 폴더이고, file system이 구현되어 있다.</li>
<li>각종 makefile 들 : 전체 프로젝트를 빌드하는 스크립트들이 적힌 파일들이다. Makefile을 처음 본다면 <a href>여기</a>에서 어떤 역할을 하는지 살펴보면 될 것 같다.</li>
</ul>
<h3 id="빌드부터-테스트까지의-과정"><a href="#빌드부터-테스트까지의-과정" class="headerlink" title="빌드부터 테스트까지의 과정"></a>빌드부터 테스트까지의 과정</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">요약</span><br><span class="line">1. make 를 실행하면 내가 만든 오에스와 내 오에스를 평가하는 테스트 프로그램이 빌드 된다</span><br><span class="line">2. make check를 실행하면 점수를 볼 수 있다</span><br><span class="line">3. 좀 더 상세한 평가를 보고 싶다면 make grade를 입력해 보자</span><br></pre></td></tr></table></figure>
<p>과제를 진행하는 폴더에서 <strong>make</strong> 명령어만 치면 우리가 작성한 코드들이 모두 컴파일 되어 시뮬레이터에서 동작하는 하나의 오에스 이미지(os.dsk)가 만들어지고, test 코드가 모두 컴파일 되어 내가 만든 결과물들을 test할 수 있는 환경이 완성된다. make를 통해 만들어 지는 모든 파일들은 /build 폴더에 담기게 된다. 즉, /threads 폴더에서 make를 친 후, /threads/build에 가보면 내가 만든 오에스의 이미지와 /tests/threads 에 있는 코드들이 컴파일 되어 있는 것을 확인할 수 있을 것이다. /build 폴더에서 <strong>pintos run [테스트 A]</strong>을 실행하면 A라는 테스트가 시뮬레이터 위에서 동작하고 그에 대한 시뮬레이션 결과를 콘솔화면에서 관찰할 수 있다.</p>
<p>모든 테스트를 한번에 확인하고 싶다면 <strong>make check</strong> 명령어를 치면 되고, 이에 대한 결과가 화면에 출력된다. 예를 들어 2번 과제를 한다면 /userprog 혹은 /userprog/build 에서 make check를 입력하면 내 과제물의 점수를 확인할 수 있다. <strong>make grade</strong>를 입력하면 내 과제물에 대한 상세한 평가가 담긴 파일이 /build 폴더 안에 생긴다.</p>
<h3 id="환경설정과-개발-프로세스"><a href="#환경설정과-개발-프로세스" class="headerlink" title="환경설정과 개발 프로세스"></a>환경설정과 개발 프로세스</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">요약</span><br><span class="line">1. 따로 개발환경을 구축하지 말고, VC서버를 사용하자</span><br><span class="line">2. github, 에디터의 ftp 설정</span><br><span class="line">3. /threads 폴더에서 make -&gt; cd build -&gt; pintos run alarm-multiple</span><br></pre></td></tr></table></figure>
<p>VC서버에 이미 과제를 위한 모든 환경설정이 되어있을 것이다. 시뮬레이터, Git, gcc 등 과제에 필요한 모든 프로그램들이 잘 세팅되어 있기 때문에 따로 개발환경을 구축하는 것보단 VC서버를 사용하는 것이 좋다. 나도 처음에 로컬에서 개발을 하는 것이 더 나을 거 같다고 생각해서(VC서버에 예상치 못한 문제가 생길 수도 있기 때문에) 위해 여러 핀토스 개발환경이 셋팅된 도커 이미지들을 구글링으로 구해보았지만 잘 작동하지 않았다.</p>
<p>우리가 해야할 것은 2가지다.</p>
<ol>
<li>github에 가서 새로운 저장소를 파서 다운 받은 핀토스 프로젝트 파일로 초기화</li>
<li>내가 사용할 에디터의 ftp 설정</li>
</ol>
<p>git 사용에 익숙하지 않다면, 기본적인 commit, push, pull, roll back 에 대한 것들을 먼저 공부하는 것이 좋다. git은 선택이 아닌 필수이다. git을 꼭 사용해야 되는 이유로는</p>
<ol>
<li>2인 1조로 서로 협업해야 한다</li>
<li>버전관리를 하지 않으면 프로그램을 만들다 문제가 생겼을 때 복구가 힘들다</li>
<li>VC서버에 오류가 생길 경우, 서버에 있는 소스 파일이 손상이 될 수가 있다.</li>
</ol>
<p>github 세팅이 완료되었다면 먼저 서버에 접속해서 git clone을 해서 핀토스를 다운 받고, 핀토스가 잘 구동되는지 꼭꼭 확인해야한다. /utils 을 $PATH에 추가하고, /threads 에서 make 를 통해 빌드를 한 후, pintos run alarm-mulitiple을 실행했을 때, 정상동작을 하는 것까지 확인하면 된다. 이에 대한 상세한 내용은 랩시간에 설명을 들을 수 있다.</p>
<p>이 후, 내가 수정한 코드가 바로 서버에 업로드 되어 빠르게 테스트 해볼 수 있게, 에디터의 ftp 설정을 추가해서 auto upload 가 되게 하는 것이 좋다. 전체적인 개발 프로세스는 다음과 같은 형태일 것이다.</p>
<ol>
<li>내 컴퓨터에서 에디터를 켜서 코드를 수정</li>
<li>수정한 코드가 ftp를 통해 서버에 전송되면 서버에서 pintos를 실행, 결과 확인</li>
<li>문제가 생기면 1번 부터 다시 시작</li>
<li>문제가 없을 시, 내 컴퓨터에서 git commit, push</li>
<li>서버에서 모든 변경사항을 지우고 git pull을 한 후, 다시 pintos를 실행</li>
</ol>
<h3 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">요약</span><br><span class="line">1. gdb를 쓰자...</span><br></pre></td></tr></table></figure>
<p>gdb를 쓰면 매우 많은 시간을 절약할 수 있을 것이다. 단순한 printf와 PANIC을 통한 출력으로는 무슨 문제가 생겼는 지 확인하는 데에 시간이 매우 많이 걸릴 것이다. 나는 gdb를 쓸 줄 몰랐기 때문에 printf와 PANIC 을 통해 디버깅을 했는데, 버그가 발생했을 때 어디서 문제가 발생했는 지 찾는 데에만 굉장히 많은 시간이 걸렸다. gdb를 모른다면 이에 대해 미리 공부한 후, 과제를 시작하는 것을 강력히 추천한다. 내가 받을 고통의 강도가 절반으로 줄어들 것이라고 장담할 수 있다. 하지만 gdb를 전혀 안써도 printf와 PANIC으로도 어떻게 어떻게 디버깅을 할 수는 있다.</p>
<h3 id="과제를-하는-방법"><a href="#과제를-하는-방법" class="headerlink" title="과제를 하는 방법"></a>과제를 하는 방법</h3><p>한 학기동안 핀토스를 체험한 결과 다음 프로세스를 따른다면 과제를 훨씬 편히 할 수 있을 뿐만 아니라 오에스에 대한 더 깊은 이해도를 가질 수 있을 것이라고 생각한다.</p>
<ol>
<li>해당 파트에 대한 개념적인 공부</li>
<li>다큐먼트, 스켈레톤 코드에 대한 충분한 이해</li>
<li>2번을 바탕으로 현재 핀토스의 문제점과 과제를 통해 개선해야 할 점 정리</li>
<li>구현 디자인</li>
<li>구현 + 디버깅</li>
</ol>
<p>내 경험상 실질적인 구현을 하기 전에 1,2,3,4 과정에 충분한 시간을 쏟는 것이 오히려 고통을 덜 받고 시간을 절약하는 길인 것 같다. 앞으로 과제에 대한 설명도 1,2,3,4 번이 중심이 될 것 같다.</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://h2oche.github.io/2019/01/26/boj4243/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h2oche">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h2oche의 블로그">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/26/boj4243/" class="post-title-link" itemprop="url">boj4243</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">작성일</span>
              

              
                
              

              <time title="Post created: 2019-01-26 22:13:37" itemprop="dateCreated datePublished" datetime="2019-01-26T22:13:37+09:00">2019-01-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2019-01-27 23:22:52" itemprop="dateModified" datetime="2019-01-27T23:22:52+09:00">2019-01-27</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/boj/" itemprop="url" rel="index"><span itemprop="name">boj</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>시간복잡도 : O(N^2)</li>
<li>점화식<ul>
<li>dp[i][j] = d[i][j-1]</li>
</ul>
</li>
</ul>
<p>다이나믹 프로그래밍을 이용해 푼 문제이다.<br>dp[i][j]의 의미는 i부터 출발해서 j까지 순찰할때 필요한 상점들의 대기시간의 총 합을 의미한다.<br>get_cost(i, j) 함수는 i부터 출발해서 j까지 이동할 때 걸리는 시간을 의미한다.</p>
<p>처음 입력받을 때, t를 부분합으로 저장하면 get_cost(i, j) 를 O(1)의 시간복잡도로 처리가능하고,<br>상점들의 대기시간의 총합도 dp를 이용해서 O(1)의 시간복잡도로 처리가능하다.</p>
<p>결국 대기시간의 총합은 dp와 get_cost를 적절히 활용한 get_min_cost라는 함수에서 이루어진다.</p>
<p>left, right를 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 101</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, start;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t[MAX_N] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[MAX_N][MAX_N] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_cost</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i &gt; j) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = i;</span><br><span class="line">    i = j;</span><br><span class="line">    j = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t[j<span class="number">-1</span>] - t[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="keyword">sizeof</span> t);</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; start;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> num; <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    t[i] = t[i<span class="number">-1</span>] + num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;=n ; j++)&#123;</span><br><span class="line">      dp[i][j] = dp[i][j<span class="number">-1</span>] + get_cost(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span> ; j &gt; <span class="number">0</span> ; j--) &#123;</span><br><span class="line">      dp[i][j] = dp[i][j+<span class="number">1</span>] + get_cost(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_min_cost</span><span class="params">(<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; left, <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; right, <span class="keyword">long</span> <span class="keyword">long</span> bias, <span class="keyword">int</span> cur_pos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> min_val = LONG_MAX;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> left_front = left.empty() ? <span class="number">0</span> : left.front();</span><br><span class="line">  <span class="keyword">int</span> right_front = right.empty() ? <span class="number">0</span> : right.front();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(left.empty()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(right.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    bias += get_cost(cur_pos, right_front - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> bias * right.size() + dp[right_front<span class="number">-1</span>][n];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(right.empty()) &#123;</span><br><span class="line">    bias += get_cost(left_front + <span class="number">1</span>, cur_pos);</span><br><span class="line">    <span class="keyword">return</span> bias * left.size() + dp[left_front+<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> c_left = left;</span><br><span class="line">  <span class="keyword">auto</span> c_right = right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!c_left.empty())&#123;</span><br><span class="line">    <span class="keyword">int</span> a = c_left.front(); c_left.pop();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cost = dp[left_front + <span class="number">1</span>][a] + (left_front + <span class="number">1</span> - a) * (bias + get_cost(cur_pos, left_front + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> n_bias = get_cost(a, cur_pos) + bias;</span><br><span class="line">    min_val = min(min_val, get_min_cost(c_left, right, n_bias, a) + cost);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!c_right.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = c_right.front(); c_right.pop();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cost = dp[right_front - <span class="number">1</span>][a] + (a - right_front + <span class="number">1</span>) * (bias + get_cost(cur_pos, right_front - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> n_bias = get_cost(a, cur_pos) + bias;</span><br><span class="line">    min_val = min(min_val, get_min_cost(left, c_right, n_bias, a) + cost);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> min_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; left, right;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = start - <span class="number">1</span> ; i &gt; <span class="number">0</span> ; i--)</span><br><span class="line">    left.push(i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">    right.push(i);</span><br><span class="line">  <span class="keyword">return</span> get_min_cost(left, right, <span class="number">0</span>, start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; results;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_results</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v : results)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">int</span> tc; <span class="built_in">cin</span> &gt;&gt; tc;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; tc ; i ++)</span><br><span class="line">    results.push_back(solve());</span><br><span class="line">  print_results();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://h2oche.github.io/2019/01/24/boj11051/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h2oche">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h2oche의 블로그">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/24/boj11051/" class="post-title-link" itemprop="url">boj11051</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">작성일</span>
              

              
                
              

              <time title="Post created: 2019-01-24 22:45:09 / Updated at: 23:27:43" itemprop="dateCreated datePublished" datetime="2019-01-24T22:45:09+09:00">2019-01-24</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/boj/" itemprop="url" rel="index"><span itemprop="name">boj</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>(n k) = (n-1 k-1) + (n-1 k) 라는 성질을 사용해서 약간 다이나믹 프로그래밍스럽게 푼 문제이다.<br>sum(a, b) 함수를 따로 정의해서 % 연산 실수를 하지 않게 노력했다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 5001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> bi[MAX_N][MAX_N] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a%M + b % M) % M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, k; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	bi[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>; bi[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		bi[i][<span class="number">0</span>] = <span class="number">1</span>, bi[i][i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">			bi[i][j] = sum(bi[i - <span class="number">1</span>][j], bi[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; bi[n][k];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://h2oche.github.io/2019/01/24/boj11003/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h2oche">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h2oche의 블로그">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/24/boj11003/" class="post-title-link" itemprop="url">boj11003</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">작성일</span>
              

              
                
              

              <time title="Post created: 2019-01-24 22:44:48 / Updated at: 23:40:59" itemprop="dateCreated datePublished" datetime="2019-01-24T22:44:48+09:00">2019-01-24</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/boj/" itemprop="url" rel="index"><span itemprop="name">boj</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>naive한 풀이는 입력을 받은 후, i = 1 -&gt; N, j -&gt; i - L + 1 -&gt; i 로 루프를 돌면서 최솟값을 찾는 것인데,<br>이 경우 문제는 L이 충분이 커졌을 때, 전체 시간복잡도가 O(N^2)이 된다는 것이다(L = N/2)</p>
<p>사실 PS 수업에서 나왔던 문제랑 거의 비슷하지만 좀 더 쉬웠던 문제여서 다양한 풀이방법을 이미 알고있었다.<br>네가지 정도의 풀이가 가능하다.</p>
<ol>
<li>priority queue를 사용한 풀이</li>
<li>segment tree를 사용한 풀이</li>
<li>기하적으로 생각한 풀이</li>
<li>deque을 사용한 풀이</li>
</ol>
<p>1,2 는 O(NlogN) 이 걸리기 때문에 시간이 꽤 걸리고, 3,4는 O(N) 이 걸린다.<br>segment tree를 활용한 풀이는 아에 시간초과가 발생했고, priority queue를 사용해서 풀어봤더니 통과했다.<br>3,4 번 방법은 이미 구현해 보았으므로 시도하지 않았다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, L;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; L;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> num; <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">		pq.push(make_pair(-num, i));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">			<span class="keyword">auto</span> min_val = pq.top();</span><br><span class="line">			<span class="keyword">if</span> (min_val.second &gt;= i - L + <span class="number">1</span>) &#123;</span><br><span class="line">				results.push_back(-min_val.first);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			pq.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; results[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://h2oche.github.io/2019/01/24/boj15688/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h2oche">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h2oche의 블로그">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/24/boj15688/" class="post-title-link" itemprop="url">boj15688</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">작성일</span>
              

              
                
              

              <time title="Post created: 2019-01-24 22:44:20 / Updated at: 23:24:42" itemprop="dateCreated datePublished" datetime="2019-01-24T22:44:20+09:00">2019-01-24</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/boj/" itemprop="url" rel="index"><span itemprop="name">boj</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>counting sort로 풀면 쉽게 풀리는 문제이다.<br>값의 범위가 이백만이라 약간 느리지만 그래도 통과한다<br>메모리 제한이 넉넉하므로 radix sort로도 통과가 가능할 것 같다(아마 더 빠를 것 같다.)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 2000002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B 1000001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> histo[MAX] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> num; <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">		histo[num + B]++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAX; i++)</span><br><span class="line">		histo[i] += histo[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = histo[i]; j &lt; histo[i + <span class="number">1</span>]; j++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; (i + <span class="number">1</span> - B) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://h2oche.github.io/2019/01/24/boj10989/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h2oche">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h2oche의 블로그">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/24/boj10989/" class="post-title-link" itemprop="url">boj10989</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">작성일</span>
              

              
                
              

              <time title="Post created: 2019-01-24 22:43:17 / Updated at: 23:21:57" itemprop="dateCreated datePublished" datetime="2019-01-24T22:43:17+09:00">2019-01-24</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/boj/" itemprop="url" rel="index"><span itemprop="name">boj</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>메모리가 c++로 구현을 했을 때 8MB 밖에 안된다. 즉, 입력받은 수들을 어떤 배열에 저장해서 정렬하려고 하면 메모리 초과가 뜨게 될 것이다(4 * 10000000 / 1024 / 1024 = 38.xx &gt; 8)<br>그런데 입력받는 수들의 범위가 10000으로 작으므로 counting sort를 구현하면 문제를 풀 수 있다.<br>counting sort는 O(N+K)의 시간복잡도를 가지고 있는 정렬방법이다.</p>
<p>만약 java로 구현한다면 radix sort로도 구현 할 수 있다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> histo[MAX] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> num; <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">		histo[num]++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAX; i++)</span><br><span class="line">		histo[i] += histo[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = histo[i]; j &lt; histo[i + <span class="number">1</span>]; j++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://h2oche.github.io/2019/01/24/boj1850/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h2oche">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h2oche의 블로그">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/24/boj1850/" class="post-title-link" itemprop="url">boj1850</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">작성일</span>
              

              
                
              

              <time title="Post created: 2019-01-24 22:43:00 / Updated at: 23:00:20" itemprop="dateCreated datePublished" datetime="2019-01-24T22:43:00+09:00">2019-01-24</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/boj/" itemprop="url" rel="index"><span itemprop="name">boj</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1로만 이루어진 수 2개가 주어졌을 때 이에 최대공약수를 구하는 문제이다.<br>1이 a개로 이루어진 수 = (10^a - 1)/9 이므로 입력이 a,b라고 했을 때<br>gcd(10^a - 1, 10^b - 1) / 9 를 구하면 된다.<br>여기서 핵심은 gcd(10^a - 1, 10^b - 1) / 9 = 1이 gcd(a,b)개로 이루어진 수 임을 증명하기만 하면 쉽게 풀 수 있다.</p>
<p>대충 설명을 하자면(a &gt;= b라고 가정) g=gcd(10^a - 1, 10^b - 1) / 9라고 했을 때, (10^a - 1)/9 = g <em> A, (10^b - 1)/9 = g </em> B 하면,<br>10^b <em> (10^(a-b)-1) / 9 = g </em> (A-B), gcd(g, 10^b) = 1(두 수 모두 끝자리가 1이기 때문) 이므로<br>g | (10^(a-b) - 1)/9 이다. 즉, a = p * b + r 이라고 했을 때, g | (10^r - 1)/9 일 것이다.<br>따라서 위와 같은 가정이 참임을 증명할 수 있다.</p>
<p>이 사실만 알아내면 간단한 구현으로 답을 얻을 수 있다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> r;</span><br><span class="line">	<span class="keyword">if</span> (a &lt; b) r = a, a = b, b = r;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		r = a % b;</span><br><span class="line">		a = b;</span><br><span class="line">		b = r;</span><br><span class="line">	&#125; <span class="keyword">while</span> (r != <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">100</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> a, b; <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> lp = gcd(a, b);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lp; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">'1'</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://h2oche.github.io/2019/01/24/boj2981/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h2oche">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h2oche의 블로그">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/24/boj2981/" class="post-title-link" itemprop="url">boj2981</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">작성일</span>
              

              
                
              

              <time title="Post created: 2019-01-24 22:42:45 / Updated at: 23:16:41" itemprop="dateCreated datePublished" datetime="2019-01-24T22:42:45+09:00">2019-01-24</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/boj/" itemprop="url" rel="index"><span itemprop="name">boj</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>최대공약수만 구하면 되는 문제인 줄 알았는데 숨겨진 문제가 하나 더 있던 문제이다.<br>답을 구하는 과정은 크게 2파트로 나뉘어진다.</p>
<ol>
<li>입력받은 수들의 차이(a1-a2, a2-a3, …) 들의 최대공약수를 구한다.</li>
<li>이렇게 구한 최대공약수들의 모든 약수들을 출력한다.</li>
</ol>
<p>왜 이런답이 나오는 지는 나머지를 r 이라고 했을 때, a1 = p1 <em> g + r, a2 = p2 </em> g + r, … 로 표시하면 쉽게 알 수 있다.<br>사실 나는 2번이 별 문제가 아닐 줄 알아서 단순히 1부터 g까지 i를 증가시키면서 약수를 출력했는데 이렇게 되면<br>2 1 1000000000 과 같은 입력이 주어졌을 때, 루프를 매우 많이 돌게 된다는 문제가 발생해서 시간초과가 계속 떴다.<br>모든 약수가 i , g / i 쌍으로 이루어 져 있다고 하면 i * i &lt;= g 일때까지만 i를 증가시키면 되므로 연산이 훨씬 줄어든다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">if</span> (a &lt; b) r = a, a = b, b = r;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		r = a % b;</span><br><span class="line">		a = b;</span><br><span class="line">		b = r;</span><br><span class="line">	&#125; <span class="keyword">while</span> (r != <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m[<span class="number">100</span>] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; m[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">		nums.insert(<span class="built_in">abs</span>(m[i] - m[i + <span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : nums)</span><br><span class="line">		q.push(v);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (q.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> a = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">int</span> b = q.front(); q.pop();</span><br><span class="line">		q.push(gcd(a, b));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> max_val = q.front();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans; ans.push_back(max_val);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= max_val; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (max_val % i == <span class="number">0</span>) &#123;</span><br><span class="line">			ans.push_back(i);</span><br><span class="line">			<span class="keyword">if</span>( max_val / i != i)</span><br><span class="line">				ans.push_back(max_val / i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(ans.begin(), ans.end());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : ans)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://h2oche.github.io/2019/01/24/boj2108/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h2oche">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h2oche의 블로그">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/24/boj2108/" class="post-title-link" itemprop="url">boj2108</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">작성일</span>
              

              
                
              

              <time title="Post created: 2019-01-24 22:41:30 / Updated at: 23:02:43" itemprop="dateCreated datePublished" datetime="2019-01-24T22:41:30+09:00">2019-01-24</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/boj/" itemprop="url" rel="index"><span itemprop="name">boj</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>데이터의 평균, 메디안, 모드, 최대최소의 차이를 구하는 문제이다.<br>STL 을 활용하면 쉽게 풀 수 있다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RANGE 8001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[MAX_N] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; histo[RANGE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RANGE; i++)</span><br><span class="line">		histo[i] = make_pair(<span class="number">0</span>, i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n; <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">		sum += d[i];</span><br><span class="line">		histo[d[i] + <span class="number">4000</span>].first++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//mean</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">floor</span>(sum / (<span class="keyword">double</span>)n + <span class="number">0.5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//median</span></span><br><span class="line">	sort(d, d + n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d[n / <span class="number">2</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//mode</span></span><br><span class="line">	sort(histo, histo + RANGE);</span><br><span class="line">	<span class="keyword">int</span> max_val = (*max_element(histo + <span class="number">0</span>, histo + RANGE)).first;</span><br><span class="line">	<span class="keyword">auto</span> bounds = equal_range(histo + <span class="number">0</span>, histo + RANGE, make_pair(max_val, <span class="number">0</span>), [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mode = (*(bounds.first)).second;</span><br><span class="line">	<span class="keyword">if</span> (bounds.second - bounds.first &gt; <span class="number">1</span>)</span><br><span class="line">		mode = (*(bounds.first + <span class="number">1</span>)).second;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; mode - RANGE / <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//min max</span></span><br><span class="line">	<span class="keyword">auto</span> mm = minmax_element(d+<span class="number">0</span>, d + n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *mm.second - *mm.first;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="다음 페이지"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">h2oche</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">34</span>
                    <span class="site-state-item-name">포스트</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">카테고리</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">태그</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">h2oche</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>




  

  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  
  






  




  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
